2019-05-20
==========================================================================

- Fixed backedges existing 2x (once for each direction)
- Special-cased the empty bracket-list (from below)

The algorithm runs correctly on a small set of inputs in the test/
directory. Still need to add more tests; in particular, we need to
exercise the codepaths that result in the creation of capping backedges.

2019-05-16
==========================================================================

Discovered a special case in the algorithm presented by The Program
Structure Tree paper. The paper assumes that the input CFG has a single
entry and single exit node; the CFG in LLVM does not guarantee this.

An artificial "source" and "sink" could be created to fill this gap and
allow the algorithm to work as-written. Or, we could simply assume that
every Node/Edge having no brackets must belong to the outermost
(all-encompassing) SESE region of the program.

So, either we special-case nodes that have no brackets; or, we
special-case dummy "source" and "sink" nodes for programs with multiple
entry and/or exit points.

The algorithm cannot run until this is resolved, except on inputs where
the outermost SESE region is itself a cycle. This would imply a program
that never returns, since any 'return' statement would have no cycle edge.

I think that the easiest solution (although not the most obvious) is to
simply treat any node that has no brackets as belonging to the special
"outermost" cycle equivalence class.

2019-05-15
==========================================================================

Paper states that the "ancestor relation" of nodes in a depth-first
spanning tree of the undirected control flow graph can be determined in
O(1) time. While this may be possible with O(E) preprocessing of the tree,
it does not appear to be possible using only the information provided by
the paper. A claim is made in "Lemma 1" on page 175 in PLDI1994 that, "if
tree edges s and t have any bracket in common then they are ordered by the
ancestor relation in the tree." This property does not give the order; it
only guarantees *an* ordering. Perhaps the authors omitted some detail
that elucidates how the existing information can allow ancestor relation
checks in O(1) time?

Decided with Simone to implement the naiive O(E) descendance relation that
simply traverses the tree in order to get around this (unimportant)
detail.
